/**
 * Refinement Round Prompt Builder
 *
 * Builds prompts for the optional refinement round where models
 * receive the winning solution and attempt to improve upon it.
 */

import { calculatePerfScore, type ReactPerfMetrics } from './react-metrics'

export interface RefinementPromptOptions {
  /** The original challenge prompt */
  originalPrompt: string
  /** The winning solution code from the initial round */
  winningSolution: string
  /** Which model produced the winning solution */
  winnerModel: string
  /** Performance metrics achieved by the winner */
  winnerMetrics: WinnerMetrics
  /** Is this prompt being sent to the model that won? */
  isWinner: boolean
  /** Challenge type for appropriate metric descriptions */
  challengeType: 'function' | 'react-component'
}

export interface WinnerMetrics {
  // Function challenge metrics
  benchmarks?: Array<{
    name: string
    hz: number
    mean?: number
  }>
  // React challenge metrics - can be either pre-computed or raw ReactPerfMetrics
  reactMetrics?: {
    fps?: { p95: number }
    renders?: { avgCommitTime: number; renderCount: number }
    bundle?: { gzipped: number }
    performanceScore?: number
  } | ReactPerfMetrics
}

/**
 * Build a refinement round prompt for a model
 */
export function buildRefinementPrompt(opts: RefinementPromptOptions): string {
  const {
    originalPrompt,
    winningSolution,
    winnerModel,
    winnerMetrics,
    isWinner,
    challengeType,
  } = opts

  const metricsDescription = formatMetrics(winnerMetrics, challengeType)
  const contextMessage = isWinner
    ? `This is YOUR solution from the initial round. You are the current leader with these metrics. Can you improve upon your own work?`
    : `Your task: analyze this solution and create an improved version that maintains correctness while achieving better performance.`

  return `# Refinement Round

You are competing in a code optimization challenge. The initial round has completed, and now all models have a chance to improve upon the best solution.

## Original Challenge

${originalPrompt}

## Current Best Solution

This solution was generated by **${winnerModel}** and achieved:
${metricsDescription}

${contextMessage}

## Winning Code

\`\`\`typescript
${winningSolution}
\`\`\`

## Your Task

Generate an improved version that:
1. **Passes all tests** - correctness is non-negotiable
2. **Achieves better performance** - optimize for ${challengeType === 'function' ? 'operations per second' : 'FPS, render efficiency, and bundle size'}

You may:
- Refactor the algorithm for better performance
- Apply micro-optimizations
- Use more efficient data structures
- Reduce unnecessary computations

You must NOT:
- Change the function/component signature
- Remove required functionality
- Introduce bugs to gain speed

Return ONLY the improved code. No explanations.`
}

/**
 * Format metrics for display in the prompt
 */
function formatMetrics(metrics: WinnerMetrics, challengeType: 'function' | 'react-component'): string {
  if (challengeType === 'function' && metrics.benchmarks) {
    return metrics.benchmarks
      .map(b => `- **${b.name}**: ${b.hz.toLocaleString()} ops/sec`)
      .join('\n')
  }

  if (challengeType === 'react-component' && metrics.reactMetrics) {
    const lines: string[] = []
    const rm = metrics.reactMetrics

    if (rm.fps?.p95) {
      lines.push(`- **FPS (p95)**: ${rm.fps.p95.toFixed(1)}`)
    }
    if (rm.renders) {
      lines.push(`- **Avg render time**: ${rm.renders.avgCommitTime.toFixed(2)}ms`)
      lines.push(`- **Render count**: ${rm.renders.renderCount}`)
    }
    if (rm.bundle?.gzipped) {
      lines.push(`- **Bundle size**: ${(rm.bundle.gzipped / 1024).toFixed(1)}KB gzipped`)
    }
    if (rm.performanceScore !== undefined) {
      lines.push(`- **Performance score**: ${rm.performanceScore.toFixed(0)}/100`)
    }

    return lines.join('\n') || '- Metrics not available'
  }

  return '- Metrics not available'
}

/**
 * Helper to extract performance score from various metric formats
 */
function getReactScore(metrics: WinnerMetrics['reactMetrics']): number {
  if (!metrics) return 0

  // Check if it's a pre-computed score
  if ('performanceScore' in metrics && typeof metrics.performanceScore === 'number') {
    return metrics.performanceScore
  }

  // Check if it's a raw ReactPerfMetrics (has 'passed' and 'thresholds')
  if ('passed' in metrics && 'thresholds' in metrics) {
    return calculatePerfScore(metrics as ReactPerfMetrics)
  }

  return 0
}

/**
 * Calculate improvement percentage between original and refined metrics
 */
export function calculateImprovement(
  original: WinnerMetrics,
  refined: WinnerMetrics,
  challengeType: 'function' | 'react-component'
): { improved: boolean; percentage: number; description: string } {
  if (challengeType === 'function') {
    const origHz = original.benchmarks?.[0]?.hz ?? 0
    const refHz = refined.benchmarks?.[0]?.hz ?? 0

    if (origHz === 0) return { improved: false, percentage: 0, description: 'No baseline' }

    const percentage = ((refHz - origHz) / origHz) * 100
    return {
      improved: percentage > 0,
      percentage,
      description: percentage > 0
        ? `+${percentage.toFixed(1)}% faster`
        : `${percentage.toFixed(1)}% slower`,
    }
  }

  // React component - compare performance scores
  const origScore = getReactScore(original.reactMetrics)
  const refScore = getReactScore(refined.reactMetrics)

  if (origScore === 0) return { improved: false, percentage: 0, description: 'No baseline' }

  const percentage = ((refScore - origScore) / origScore) * 100
  return {
    improved: percentage > 0,
    percentage,
    description: percentage > 0
      ? `+${percentage.toFixed(1)}% better score`
      : `${percentage.toFixed(1)}% worse score`,
  }
}
